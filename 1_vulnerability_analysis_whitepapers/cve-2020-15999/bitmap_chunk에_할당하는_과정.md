- ### `bitmap chunk`를 할당하는 과정

  ```c
  FT_BASE_DEF( FT_Error )
  ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
                             FT_ULong      size )
  {
    FT_Memory  memory = FT_FACE_MEMORY( slot->face );
    FT_Error   error;
  
    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
      FT_FREE( slot->bitmap.buffer );
    else
      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
  
    FT_MEM_ALLOC( slot->bitmap.buffer, size ); // [A]
    return error;
  }
  ```

  - 아래 코드를 요약하면 `FT_MEM_ALLOC` 전처리기 함수에서 `ft_mem_alloc` 함수를 통해 메모리를 할당받고 `ptr`에 저장합니다.

  ```c
  #define FT_MEM_ALLOC( ptr, size )                               \
          FT_ASSIGNP_INNER( ptr, ft_mem_alloc( memory, (FT_Long)(size), &error ) )
  ```

  ```c
    // ftutil.c
    FT_BASE_DEF( FT_Pointer )
    ft_mem_alloc( FT_Memory  memory,
                  FT_Long    size,
                  FT_Error  *p_error )
    {
      FT_Error    error;
      FT_Pointer  block = ft_mem_qalloc( memory, size, &error );
  
      if ( !error && block && size > 0 )
        FT_MEM_ZERO( block, size );
  
      *p_error = error;
      return block;
    }
  ```

  ```c
    // ftutil.c  
    FT_BASE_DEF( FT_Pointer )
    ft_mem_qalloc( FT_Memory  memory,
                   FT_Long    size,
                   FT_Error  *p_error )
    {
      FT_Error    error = FT_Err_Ok;
      FT_Pointer  block = NULL;
  
      if ( size > 0 )
      {
        block = memory->alloc( memory, size ); // [A]
        if ( !block )
          error = FT_THROW( Out_Of_Memory );
      }
      else if ( size < 0 )
      {
        /* may help catch/prevent security issues */
        error = FT_THROW( Invalid_Argument );
      }
  
      *p_error = error;
      return block;
    }
  ```

  ```c
  struct  FT_MemoryRec_
    {
      void*            user;
      FT_Alloc_Func    alloc;
      FT_Free_Func     free;
      FT_Realloc_Func  realloc;
    };
  ```