### libpng 내에서 Heap Overflow가 발생하는 위치

```c
// pngread.c
void PNGAPI
png_read_image(png_structrp png_ptr, png_bytepp image)
{
   png_uint_32 i, image_height;
   int pass, j;
   png_bytepp rp;
   ...

/*
// pnglibconf.h
#define PNG_READ_INTERLACING_SUPPORTED
*/

#ifdef PNG_READ_INTERLACING_SUPPORTED
   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
   {
      pass = png_set_interlace_handling(png_ptr);
      /* And make sure transforms are initialized. */
      png_start_read_image(png_ptr);
   }
   else
   {
      ...
      pass = png_set_interlace_handling(png_ptr); // png_ptr->interaced가 참이면 7 리턴 아니라면 1 리턴
   }
#else
	 ...
#endif

   image_height=png_ptr->height; // [A]

   for (j = 0; j < pass; j++)
   {
      rp = image;
      for (i = 0; i < image_height; i++)
      {
         png_read_row(png_ptr, *rp, NULL); // [B]
         rp++;
      }
   }
}
```

- `png_set_interlace_handling` 함수

  ```c
  // pngtrans.c
  int PNGAPI
  png_set_interlace_handling(png_structrp png_ptr)
  {
     png_debug(1, "in png_set_interlace handling");
  
     if (png_ptr != 0 && png_ptr->interlaced != 0)
     {
        png_ptr->transformations |= PNG_INTERLACE; // #define PNG_INTERLACE           0x0002U
        return (7);
     }
  
     return (1);
  }
  ```

- [A] : png 헤더에 저장된 32bit의 `height` 값을 `image_height`에 저장합니다.

- [B] : `png_read_row` 함수를 호출하여 한 열씩 읽어옵니다.

```c
// pngread.c
void PNGAPI
png_read_row(png_structrp png_ptr, png_bytep row, png_bytep dsp_row)
{
   ****png_row_info row_info;

	 ...

   /* png_read_start_row sets the information (in particular iwidth) for this
    * interlace pass.
    */
   if ((png_ptr->flags & PNG_FLAG_ROW_INIT) == 0)
      png_read_start_row(png_ptr);

   /* 1.5.6: row_info moved out of png_struct to a local here. */
   **row_info.width** = png_ptr->iwidth; /* NOTE: width of current interlaced row */ // [A] : png_read_start_row에서 설정
   row_info.color_type = png_ptr->color_type;
   row_info.bit_depth = png_ptr->bit_depth;
   row_info.channels = png_ptr->channels;
   row_info.pixel_depth = png_ptr->pixel_depth;
   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);

	 ...

   /* Fill the row with IDAT data: */
   png_ptr->row_buf[0]=255; /* to force error if no data was found */
   png_read_IDAT_data(png_ptr, png_ptr->row_buf, row_info.rowbytes + 1);

   if (png_ptr->row_buf[0] > PNG_FILTER_VALUE_NONE) // png.h // #define PNG_FILTER_VALUE_NONE  0
   {
      if (png_ptr->row_buf[0] < PNG_FILTER_VALUE_LAST)
         png_read_filter_row(png_ptr, &row_info, png_ptr->row_buf + 1,
             png_ptr->prev_row + 1, png_ptr->row_buf[0]); // png.h // #define PNG_FILTER_VALUE_LAST  5
      else
         png_error(png_ptr, "bad adaptive filter value");
   }

   /* libpng 1.5.6: the following line was copying png_ptr->rowbytes before
    * 1.5.6, while the buffer really is this big in current versions of libpng
    * it may not be in the future, so this was changed just to copy the
    * interlaced count:
    */
   memcpy(png_ptr->prev_row, png_ptr->row_buf, row_info.rowbytes + 1);

	 ...

/*
// pnglibconf.h
#define PNG_READ_INTERLACING_SUPPORTED
*/
#ifdef PNG_READ_INTERLACING_SUPPORTED
   /* Expand interlaced rows to full size */
   if (png_ptr->interlaced != 0 &&
      (png_ptr->transformations & PNG_INTERLACE) != 0)
   {
			...
      if (row != NULL)
         png_combine_row(png_ptr, row, 0/*row*/); // [B]
   }

   else
#endif
	 ...
}
```

- [A] : **`png_ptr->iwidth`** 저장되는 위치

  ```c
  void /* PRIVATE */
  png_read_start_row(png_structrp png_ptr)
  {
   	 ...
  	 if (png_ptr->interlaced != 0)
     {
        ...
        **png_ptr->iwidth** = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];
     }
  
     else
     {
        png_ptr->num_rows = png_ptr->height;
        **png_ptr->iwidth** = png_ptr->width;
     }
  	 ...
  }
  ```

- [B] : `png_combine_row` 함수를 호출합니다. 이 함수에서 Heap Overflow가 발생합니다.

```c
// pngrutil.c
void /* PRIVATE */
png_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)
{
   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
   png_const_bytep sp = png_ptr->row_buf + 1;
   png_alloc_size_t row_width = png_ptr->width;
   unsigned int pass = png_ptr->pass;
   png_bytep end_ptr = 0;
   png_byte end_byte = 0;
   unsigned int end_mask;

	 ...
         switch (bytes_to_copy)
         {
            case 1:
               ...

            case 2:
               ...

            case 3:
               ...

            default:
#if PNG_ALIGN_TYPE != PNG_ALIGN_NONE
               /* Check for double byte alignment and, if possible, use a
                * 16-bit copy.  Don't attempt this for narrow images - ones that
                * are less than an interlace panel wide.  Don't attempt it for
                * wide bytes_to_copy either - use the memcpy there.
                */
               if (bytes_to_copy < 16 /*else use memcpy*/ &&
                   png_isaligned(dp, png_uint_16) &&
                   png_isaligned(sp, png_uint_16) &&
                   bytes_to_copy % (sizeof (png_uint_16)) == 0 &&
                   bytes_to_jump % (sizeof (png_uint_16)) == 0)
               {
                  /* Everything is aligned for png_uint_16 copies, but try for
                   * png_uint_32 first.
                   */
                  if (png_isaligned(dp, png_uint_32) &&
                      png_isaligned(sp, png_uint_32) &&
                      bytes_to_copy % (sizeof (png_uint_32)) == 0 &&
                      bytes_to_jump % (sizeof (png_uint_32)) == 0)
                  {
										 /*
											// pngpriv.h
										  #  define png_aligncast(type, value) ((void*)(value))            // void로 형변환 
										  #  define png_aligncastconst(type, value) ((const void*)(value)) // const void로 형변환 
										 */
                     png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);
										 png_const_uint_32p sp32 = png_aligncastconst(
                         png_const_uint_32p, sp);
                     size_t skip = (bytes_to_jump-bytes_to_copy) /
                         (sizeof (png_uint_32));

                     do
                     {
                        size_t c = bytes_to_copy;
                        do
                        {
                           ***dp32**++ = ***sp32**++; // [D] : Heap BOF!!!
                           **c** -= (sizeof (png_uint_32));
                        }
                        while (**c** > 0);

                        if (**row_width** <= **bytes_to_jump**)
                           return;

                        dp32 += **skip**;
                        sp32 += **skip**;
                        row_width -= bytes_to_jump;
                     }
                     while (**bytes_to_copy** <= **row_width**);

                     /* Get to here when the row_width truncates the final copy.
                      * There will be 1-3 bytes left to copy, so don't try the
                      * 16-bit loop below.
                      */
                     dp = (png_bytep)dp32;
                     sp = (png_const_bytep)sp32;
                     do
                        *dp++ = *sp++;
                     while (--row_width > 0);
                     return;
                  }

	 ...
}
```

- [D] : 해당 코드를 실행할 때 chunk의 범위를 벗어난 곳에 값을 입력하여 Heap Overflow가 발생합니다.