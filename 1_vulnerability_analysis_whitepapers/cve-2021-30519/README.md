# CVE-2021-30519
1. [초록](#1-초록)   
2. [Description: UAF from Payments in Google Chrome](#2-description-uaf-from-payments-in-google-chrome)   
2.1. [Payment Request API](#21-payment-request-api)   
2.2 [정리](#22-정리)   
3. [취약점 재현법](#3-취약점-재현법)   
4. [Root Cause 분석](#4-root-cause-분석)   
4.1. [코멘트와 패치 커밋 메시지 분석](#41-코멘트와-패치-커밋-메시지-분석)   
  4.1.1. [코멘트-Root cause 분석 코멘트](#411-코멘트-root-cause-분석-코멘트)   
  4.1.2. [코멘트-Variant cases에 관한 문제 제기](#412-코멘트-variant-cases에-관한-문제-제기)   
  4.1.3. [패치의 커밋 메시지](#413-패치의-커밋-메시지)   
4.2. [패치 내역 분석](#42-패치-내역-분석)   
  4.2.1. [주요 객체 확인](#421-주요-객체-확인)   
  4.2.2. [패치 내역 분석](#422-패치-내역-분석)   
5. [결론](#5-결론)   

---

# 1. 초록

크롬 90.0.4430.212 버전 이전 버전에 모두 해당되는 크롬의 Payments 프로세스에서 발생하는 **UAF** 보안 약점이다.

OS: Windows 10, Linux

1. 사전에 유저의 크롬에 malicious payments app을 설치해 둔 상태에서, 
2. 특수한 HTML 파일을 통해 heap corruption을 일으키고, 
3. 이어서 sandbox escape를 야기할 수 있다는 점에서 취약점이 될 수 있다.


# 2. Description: UAF from Payments in Google Chrome

- Question: What is a "Payments" in Google Chrome?

## 2.1. Payment Request API

참고자료: [https://developers.google.com/web/updates/2018/06/payment-handler-api](https://developers.google.com/web/updates/2018/06/payment-handler-api)

주요 기능: 브라우저 상에서의 결제를 가능케 한다.

세부 기능:

- 결제 인증 정보를 수집한다.
- 소비자로부터 배송&연락처 정보를 수집한다.
- 빠르고 쉬운 유저 인터페이스를 제공한다.

## 2.2. 정리

`Payments` 란, 크롬 웹 브라우저 상에서 결제를 할 수 있도록 해주는 application API이다.


# 3. 취약점 재현법

취약점 재현 방식에는 쉬운 방식 하나, 조금 어려운 방식 하나, 두 가지가 있다.

1. 쉬운 방식: poc2.gif
    - Open [https://liquangumax.github.io/lindapay/](https://liquangumax.github.io/lindapay/) , install
    - Open [https://liquangumax.github.io/lindapay2/](https://liquangumax.github.io/lindapay2/) , install
    - Open [https://maxlgu.github.io/pr/lindapay-github/](https://maxlgu.github.io/pr/lindapay-github/) , buy
    - Click "continue"
    - Click the link "Directory Picker"
    - Click "Open the file dir", click "select"
    - Click the back button, boom
2. 어려운 방식: poc1.gif(이 방법은 이제 안됨)
    - open [https://skilful-reserve-239412.appspot.com/static/apps/navigation-tester/](https://skilful-reserve-239412.appspot.com/static/apps/navigation-tester/) and install
    - open [https://skilful-reserve-239412.appspot.com/static/apps/max-nonbasiccard/](https://skilful-reserve-239412.appspot.com/static/apps/max-nonbasiccard/) and install
    - open [https://maxlgu.github.io/pr/max-nonbasiccard/](https://maxlgu.github.io/pr/max-nonbasiccard/) and click Buy
    - Navigate to a Dialog pop up Page and then click the Back button ,Boom

어려운 방식은 서버가 닫혀 실행이 불가능했으며, 쉬운 방식으로만 재현할 수 있었다.


# 4. Root Cause 분석

## 4.1. 코멘트와 패치 커밋 메시지 분석

### 4.1.1. 코멘트-Root cause 분석 코멘트

> From comment 21(번역):
> 
> 
> `payment_handler_web_flow_view_controller` 의 `dialog_manager_delegate_` 가 `web_contents_modal_dialog_manager` 에 사용되기 전의 어딘가에서 released되는 것 같다.  어떻게 이런 일이 일어날 수 있는지 아직 나로서는 확실히 모르겠다.
> 

> From comment 23(번역):
> 
> 
> ```powershell
> The browser process crash log:
> (2cc0.2ff4): Access violation - code c0000005 (first chance)
> First chance exceptions are reported before any exception handling.
> This exception may be expected and handled.
> chrome_7ffd672c0000!ovly_debug_event+0x1ea219b:
> 00007ffd`6d510ffb 488b00          mov     rax,qword ptr [rax] ds:efefefef`efefefef=????????????????
> 0:000> kv
> ```
> 

> From comment 46(번역):
> 
> 
> `web_contents_modal_dialog_manager.cc` 과 연관된 클래스가 맞다.
> 

> From comment 49(번역):
> 
> 
> comment 21이 맞는 것 같다. 이런 현상을 제대로 고치려면 `PaymentHandlerWebFlowViewController` 가 `WebContentsModalDialogManager` 에 걸린 `dialog_manager_delegate_` 를, `delegate`[1] 가 삭제되기 전에 먼저 없애도록(unset) 해야 할 것 같다. 
> 
> ([1]: delegate는 메소드를 다른 메소드로, 파라미터로서 전달할 때 해당 메소드를 정의하는 타입이다.)
> 
> 다른 `WebContentsModalDialogManager` 객체에 대해 앞서 설명한 기능이 구현된 사례는 [여기](https://source.chromium.org/chromium/chromium/src/+/master:chrome/browser/ash/login/ui/webui_login_view.cc;drc=3eb027037d29138f58f98356af0295fc17030f0e;l=142) 에서 확인 요망!
> 

### 4.1.2. 코멘트-Variant cases에 관한 문제 제기

Comment 49에서 제시한 방법대로 패치하니 괜찮아졌다는 댓글이 달렸고, 뒤이어 Variant cases에 대한 고찰이 제기되었다.


> From comment 51(번역):
> 
> 
> 동일 패치를 적용해야 하는, 즉 `dialog_manager_delegate` 를 없애도록(unset) 고쳐야 하는 다른 `dialog` 객체들이 있나? 우리가 최근에 만든 `SPC` dialog 같은 것들이 좀 불안하다.
> 

> From comment 53(번역):
> 
> 
> Comment 51번에게. 지금 우리가 고친 이게 `WebContentsModalDialogManager::SetDelegate()` 를 사용하는 유일한 payment 코드이다. 저번에 만든 `SPC` 의 경우 `WebContentsModalDialogManager` 를 쓰지 않기 때문에 괜찮다.
> 


### 4.1.3. 패치의 커밋 메시지

```cpp
지금부터 서술될 패치 내용은 아래의 버그에 대한 것입니다:

[https://chromium.googlesource.com/chromium/src/+/8f6ad3de87d3d7b375f75004b1389604887d31fb](https://chromium.googlesource.com/chromium/src/+/8f6ad3de87d3d7b375f75004b1389604887d31fb)

commit

[8f6ad3de87d3d7b375f75004b1389604887d31fb](https://crrev.com/8f6ad3de87d3d7b375f75004b1389604887d31fb)

(...)

<데스크탑의 `Payment` UI에서 `WebContentsModalDialogManagerDelegate` 를 삭제하는 패치>

`payment_request_dialog_view` 의 `controller_map_` 은

`PaymentHandlerWebFlowViewController` 와 그에 대응되는  `web-view` 를 key-value 쌍으로 저장하는 객체입니다.  `payment_request_dialog_view`의 view stack에서 `web-view` 하나가 pop될 때, 이것의 키 쌍(`PaymentHandlerWebFlowViewController`)은 삭제되어야 합니다. 만일 `PaymentHandlerWebFlowViewController`가 `controller_map_` 의 소멸자(destructor) 안에 있는 

`WebContentsModalDialogManager` 의 `delegate` 를  없애지 못할 경우, `web-view` 의 소멸자가 이후 `WebContentsModalDialogManager` 의 `delegate` 에 접근 시도를 하게 됨으로써 Use-After-Free 크래시가 발생하게 됩니다.

패치를 위한 커밋은

`PaymentHandlerWebFlowViewController`의 소멸자가

`WebContentsModalDialogManager` 의 `delegate` 를 삭제(reset) 하게 함으로써 문제를 해결한 상황입니다.

~~[Bug: 1194058](https://bugs.chromium.org/p/chromium/issues/detail?id=1194058)~~

Change-Id: Iead54db4b3e682bbccccddf335780c5ceff2e990

Reviewed-on:

[https://chromium-review.googlesource.com/c/chromium/src/+/2844509](https://chromium-review.googlesource.com/c/chromium/src/+/2844509)

(...)

Cr-Commit-Position: refs/heads/master@{#875868}

[modify]

[https://crrev.com/8f6ad3de87d3d7b375f75004b1389604887d31fb/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc](https://crrev.com/8f6ad3de87d3d7b375f75004b1389604887d31fb/chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc)
```

## 4.2. 패치 내역 분석

### 4.2.1. 주요 객체 확인

먼저 4.1.3절에 명시된 커밋 메시지와 전체적인 코드 오디팅 결과를 토대로 간략하게 관계도를 그려보았다.

![<그림 1>-문제 상황이 발생한 코드에 개입된 오브젝트들의 전체적인 관계](CVE-2021-30519%20b0d2dd219c0842beab126cdbab162ac2/InkedCVE1.jpg)

<그림 1>-문제 상황이 발생한 코드에 개입된 오브젝트들의 전체적인 관계

위 구조에 표시된 오브젝트들 중, `controller_map`에 대해서 코드 오디팅을 수행했다.

- `controller_map_`
    
    `payment_request_dialog_view.h` 에 선언된 해당 모듈 내부에서 사용되는 `controller_map_` 의 형태를 정의한 코드이다. 
    
    ```cpp
    using ControllerMap =
        std::map<views::View*, std::unique_ptr<PaymentRequestSheetController>>; //(1)
    		(...)
    };
    ```
    
    (1)에서 확인된 바와 같이, `controller_map_` 은 위의 <그림 1> 에 표시된 대로 <`View*` : `PaymentRequestSheetController`> 가 <key:value> 쌍으로 짝지어져 있는 c++의 map 객체로 선언되어 있음을 알 수 있다. `PaymentRequestSheetController` 는 `PaymentHandlerWebFlowViewController` 로 사용되며, 앞으로는 `controller`로 칭한다. 정리하자면,  `controller` 객체의 key는 `views::View*` 타입의 객체이며, 이에 대해 `controller` 를 이용해 접근할 수 있다.
    
    - `controller_map_` 을 이용해 대응되는 `View*` 타입 객체에 접근하는 과정
        - `CreateViewAndInstallController` 에 대응 key를 찾고 싶은 `controller` 객체를 인자로 넘긴다.
            
            ```cpp
            std::unique_ptr<views::View> CreateViewAndInstallController(
                std::unique_ptr<PaymentRequestSheetController> controller,
                payments::ControllerMap* map) {
              std::unique_ptr<views::View> view = controller->CreateView();
              (*map)[view.get()] = std::move(controller);
              return view; // (1)
            }
            ```
            
- `PaymentHandlerWebFlowViewController` 와 `WebContentsModalDialogManager` 의 관계:
    
    아래 `PaymentHandlerWebFlowViewController` 를 보면, 처음 웹 페이지를 콜하여 페이지에 보여줄 때 `WebContentsModalDialogManager` 를 웹페이지 상에서 결제하는 `Payment API` 의 `Handler` 격으로 사용한다는 것을 알 수 있다. 즉, 이 둘은 생애 주기를 같이 하게 될 수밖에 없다.
    
    ```cpp
    void PaymentHandlerWebFlowViewController::FillContentView(
        views::View* content_view) {
      // The first time this is called, also create and add the header/content
      // separator container children.  This must be done before calling
      // LoadInitialURL() below so these will be set up before that calls back to
      // LoadProgressChanged(), and it can't be done in the constructor since the
      // container doesn't exist yet.
      (...)
      PaymentHandlerNavigationThrottle::MarkPaymentHandlerWebContents(
          web_contents());
      web_contents()->SetDelegate(this);
    	(...)
      // Enable modal dialogs for web-based payment handlers.
      dialog_manager_delegate_.SetWebContents(web_contents());
      web_modal::WebContentsModalDialogManager::CreateForWebContents(
          web_contents());
      web_modal::WebContentsModalDialogManager::FromWebContents(web_contents())
          ->SetDelegate(&dialog_manager_delegate_);
    	(...)
    }
    ```
    

### 4.2.2. 패치 내역 분석

이 절에서는 패치가 어떻게 이루어졌는지, 그것이 끼치는 영향은 어떠한지 분석한다. 

분석에 앞서, 이해의 용이함을 위해 이 절의 결과로 산출된 정상적으로 처리되는 상황의 도식과 문제가 발생할 때의 도식을 명시하겠다.

![<그림 2>-정상적으로 처리될 때의 도식](CVE-2021-30519%20b0d2dd219c0842beab126cdbab162ac2/CVE2.drawio.png)

<그림 2>-정상적으로 처리될 때의 도식

![<그림 3>-이미 삭제된 web-view 객체에 대한 후처리가 이루어지지 않았을 때의 도식(UAF 발생)](CVE-2021-30519%20b0d2dd219c0842beab126cdbab162ac2/cve3.drawio.png)

<그림 3>-이미 삭제된 web-view 객체에 대한 후처리가 이루어지지 않았을 때의 도식(UAF 발생)

- chrome/browser/ui/views/payments/view_stack.cc
    
    `Payment_request_dialog_view` 에서 view_stack_ 을 pop 할 때, 어떤 일이 일어나는지 정확히 알아보기 위해 `view_stack_→Pop()` 의 코드를 오디팅했다.
    
    ```cpp
    void ViewStack::Pop(bool animate) {
      DCHECK_LT(1u,
                GetSize());  // There must be at least one view left after popping.
    
      // Set the second-to-last view as visible, since it is about to be revealed
      // when the last view animates out.
      stack_[GetSize() - 2]->SetVisible(true);
    
      if (animate) {
        gfx::Rect destination = bounds();
        destination.set_origin(gfx::Point(width(), 0));
        slide_out_animator_->AnimateViewTo(stack_.back(), destination);
      } else {
        RemoveChildViewT(stack_.back()); //(1)
        stack_.pop_back();
      }
    }
    ```
    
    (1): `RemoveChildViewT` 는 결론적으로 `RemoveChildeView` 를 수행하는데, 이는 통상적인 `View::~View()` 내부에서 수행하는 `RemoveChildView` 와 동일한 기능을 한다. 즉, `ViewStack::Pop` 에서 `RemoveChildViewT` 가 call된다는 것은 `View` 타입 객체의 소멸자가 수행되는 것과 비슷하다고 볼 수 있다. 또한, `stack_` 는 `Views::view*` 타입에 대한 벡터이므로, `View` 타입 객체가 삭제됨과 동시에 `Views::view*`, 즉 해당 `View` 와 매핑된 `controller` 도 소멸된다. 
    

현재까지의 코드 오디팅 결과를 정리하면, <그림 2> 에 명시된 대로 `view_stack_` 에 저장되어 있던 `View` 타입 객체가 `Pop` 되었을 때 해당 객체에 대한 소멸이 진행되며, 해당 `View` 와 매핑된 `controller` 도 소멸된다는 결론을 낼 수 있다.

- chrome/browser/ui/views/payments/payment_handler_web_flow_view_controller.cc
    
    `View` 객체에 대한 Pop이 진행될 때 어떤 결과가 나오는지 확인했으므로, 이제는 패치된 코드가 각각 무엇을 의미하는지 확인한다.
    
    ```cpp
    // 변경 전 코드
    PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {
      state()->OnPaymentAppWindowClosed();
    }
    
    // 변경 후 코드
    PaymentHandlerWebFlowViewController::~PaymentHandlerWebFlowViewController() {
      if (web_contents()) {
        auto* manager = web_modal::WebContentsModalDialogManager::FromWebContents(
            web_contents());
        if (manager)
          manager->SetDelegate(nullptr);
      }
      state()->OnPaymentAppWindowClosed();
    }
    ```
    
    `PaymentHandlerWebFlowViewController` 의 소멸자가 패치되었음을 알 수 있다.
    
    앞서 서술했던 `ViewStack::Pop` 의 소스 코드 중 `RemoveChildViewT(stack_.back());`  의 실행 흐름을 감안하여 패치 전의 코드 흐름은
    
    1. `stack_.back()` 콜백 함수가 먼저 실행됨
    2. 따라서 `Controller` 의 소멸자인 `~PaymentHandlerWebFlowViewController` 가 실행됨, `Controller`를 관장하는 핸들러 격의 객체인  `WebContentsModalDialogManagerDelegate` 는 관리되지 않고 그대로 남음.
    3. 이후 `RemoveChildViewT` 의 코드부가 실행되며 `View*` 타입 객체가 소멸됨
    4. `View*` 타입 객체가 소멸되는 와중에 다시 `WebContentsModalDialogManagerDelegate` 에 access 하려 시도함
    5. Use-After-Free 발생
    
    이었음을 알 수 있다.
    
    패치 내역과 그것의 영향을 더 자세히 알아보기 위해서 코드의 콜 관계를 분석해 아래 <그림 4>를 그렸다.
    
    ![<그림 4>-패치 후 코드의 콜 관계](CVE-2021-30519%20b0d2dd219c0842beab126cdbab162ac2/codeaudit.png)
    
    <그림 4>-패치 후 코드의 콜 관계
    
    즉, 현재 페이지의 웹 컨텐츠가 존재할 경우 그 웹 컨텐츠와 연관된 key를 관리하는 포인터를 주게 되는데, 그 포인터를 패치 상의 `auto* manager` 가 저장하며, 현재 페이지의 웹 컨텐츠는 존재할 수밖에 없기 때문에 `if(manager)` 의 branch 안으로 코드 흐름이 들어가게 된다.
    
    현재 `manager` 가 저장한 웹 컨텐츠의 key를 관리하는 포인터는 `WebContentsModalDialogManager` 를 가리키는 포인터가 된다.[2]  `manager->SetDelegate(nullptr)` 을 통해 `WebContentsModalDialogManagerDelegate` 가 `nullptr` 로 설정되므로[3] 올바르게 reset 됨을 알 수 있다. 
    
    따라서, 패치 후의 코드 흐름은 이렇게 된다:
    
    1. `stack_.back()` 콜백 함수가 먼저 실행됨
    2. 따라서 `Controller` 의 소멸자인 `~PaymentHandlerWebFlowViewController` 가 실행됨.(`PaymentHandlerWebFlowViewController` 소멸 완료, 즉 이를 관장하는 `WebContentsModalDialogManagerDelegate` 또한 reset)
    3. 이후 `RemoveChildViewT` 의 코드부가 실행되며 `View*` 타입 객체가 소멸됨
    4. `View*` 타입 객체가 소멸되는 와중에 다시 `WebContentsModalDialogManagerDelegate` 에 access 하려 시도함
    5. 그러나 이미 제대로 reset 된 객체에 접근을 시도하는 것이므로, 이미 상정된 오류 범위 내에 들어 오류 없이 프로그램 실행.
    
    ([2]: `components/web_modal/web_contents_modal_dialog_manager.cc` 소스 코드를 오디팅하면 `WebContentsModalDialogManager`는 `content::WebContents` 타입을 `using` 커맨드로 사용하고 있음을 알 수 있다. )
    
    ([3]: `WebContentsModalDialogManager::SetDelegate` 코드는 아래와 같다.
    
    ```cpp
    void WebContentsModalDialogManager::SetDelegate(
        WebContentsModalDialogManagerDelegate* d) {
      delegate_ = d;//raw_ptr<WebContentsModalDialogManagerDelegate> delegate_
    
      for (const auto& dialog : child_dialogs_) {
        // Delegate can be null on Views/Win32 during tab drag.
        dialog.manager->HostChanged(d ? d->GetWebContentsModalDialogHost()
                                      : nullptr);
      }
    }
    ```
    
    )
    

# 5. 결론

이 취약점은 특정 개체와 생애주기가 긴밀히 연관된 다른 객체의 생애주기를 신경쓰지 않아 발생한 취약점이다. 크롬에서 발생하는 주요 취약점 중 Object Lifetime으로 인해 발생한 문제가 상당히 높은 비율을 차지하고 있다는 사실을 감안했을 때 그닥 놀라운 사실은 아니다.

차후 이와 비슷한 종류의 취약점(Object Lifetime)을, 동일한 어택 벡터(Payments)에서 발생시킬 수 있을까 고민해 보았으나, 4-1-2에 언급된 대로 동일 객체(`WebContentsModalDialogManager` 혹은 그것의 delegate)로 인해 발생하는 variant cases는 없는 것에 가깝다는 점으로 인해 퍼저를 위한 유력 어택 벡터 선정 과정에서 탈락하게 되었다. 개인적으로 전자결제 과정에서 웹 브라우저 프로세스의 허점으로 인해 발생하는 취약점에 관심이 많았는지라 아쉬운 결말이었다. 

글쓴이: 이윤희(toubva@gmail.com)
